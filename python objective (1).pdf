{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 1.\n",
    "a)By passing iter() function"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 2.\n",
    "b) a generarator function"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 3. \n",
    "c)1,9,36,100"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 4.\n",
    "c) All of the above"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 5.\n",
    "d)50"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 6.\n",
    "c) I got decorated\n",
    "  I am oridinary"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 7.\n",
    "d)@property"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 8.\n",
    " a)getters() and setters()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 9. Statement  is True\n",
    "d) None of the above"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 10. statements is true\n",
    "B). Both printHello() and the reference to the same object"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "a= 20\n"
     ]
    }
   ],
   "source": [
    "def outerFunction():\n",
    "    global a\n",
    "    a = 20\n",
    "    def innerFunction():\n",
    "        global a\n",
    "        a = 30\n",
    "        print('a=', a)\n",
    "a = 10\n",
    "outerFunction()\n",
    "print('a=',a)\n",
    "    "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 12. statements true\n",
    "a) A class is ablueprint for the object"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 13.Out put of the code\n",
    "c) Java"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 14. __init__() function in python\n",
    " b) This function is called when the new object is instantiated"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "1 1\n"
     ]
    }
   ],
   "source": [
    "class Point:\n",
    "    def __init__(self, x = 0, y = 0):\n",
    "      self.x = x+1\n",
    "      self.y = y+1\n",
    "      \n",
    "p1 = Point()\n",
    "print(p1.x, p1.y)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 16. code uses the inheritance feature of Python?\n",
    "c)\n",
    "class Foo:\n",
    "    pass\n",
    "class Hoo(Foo)\n",
    "    pass\n",
    " "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 17. class is derived from two different classes, it's called ______\n",
    "b) Multiple Inheritance"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 18. Which of the following statements is true?\n",
    "d) All of the above"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "4 6\n"
     ]
    }
   ],
   "source": [
    "class Point:\n",
    "    \n",
    "    def  __init__(self, x = 0, y=0):\n",
    "        self.x = x\n",
    "        self.y = y\n",
    "        \n",
    "    def __sub__(self, other):\n",
    "        x = self.x+other.x\n",
    "        y = self.y+other.y\n",
    "        return Point(x,y)\n",
    "    \n",
    "p1 = Point(3,4)\n",
    "p2 = Point(1,2)\n",
    "result = p1-p2\n",
    "print(result.x, result.y)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 20. Opening file in 'a' mode\n",
    "c) opens the file for appending, at the end of file"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 21. \n",
    "Opens test.txt file for reading only"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 22. a)\n",
    "Using the with statement. This ensures that the file is closed when the block inside with is exited.\n",
    "\n",
    "We don't need to explicitly call the close() method. It is done internally.\n",
    "    "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 23. \n",
    "a) reads the contents of the test.txt file "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 24. os.listdir()\n",
    "c) prints all the directories and files inside"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 25.  Exception\n",
    "d) All of the above\n",
    " "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 26. c) An exception is raised"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "2.0\n"
     ]
    }
   ],
   "source": [
    "number= 5.0\n",
    "try:\n",
    "    r = 10/number\n",
    "    print(r)\n",
    "except:\n",
    "    print(\"OOps\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {},
   "outputs": [],
   "source": [
    "try:\n",
    "    pass\n",
    "except(TypeError, ZeroDivisionError):\n",
    "    print(\"Two\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 28.\n",
    "d) PrintsTwo only if both TypeError and ZeroDivisionError exception occur."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 29. \n",
    "c)  we can create the user defined  exception by deriving a class from Exception class"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 30. \n",
    "d) All of the above"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Python is awesome\n"
     ]
    }
   ],
   "source": [
    "def printLine(text):\n",
    "    print(text, 'is awesome')\n",
    "    \n",
    "printLine('Python')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 32. \n",
    "b) None object"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Hello ('Frodo', 'Sauron')\n"
     ]
    }
   ],
   "source": [
    "def greet(*name):\n",
    "    print('Hello',name)\n",
    "    \n",
    "greet('Frodo', 'Sauron')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 34. Recursive\n",
    "b) A function that calls itself"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "25\n"
     ]
    }
   ],
   "source": [
    "result = lambda x:x * x\n",
    "print(result(5))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 29,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "10\n"
     ]
    }
   ],
   "source": [
    "def Foo(x):\n",
    "    if(x==1):\n",
    "        return 1\n",
    "    else:\n",
    "        return x+Foo(x-1)\n",
    "\n",
    "print(Foo(4))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 40,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "3.141592653589793\n"
     ]
    }
   ],
   "source": [
    "from math import pi\n",
    "print(pi)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 38. Operator\n",
    "a) .operator"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 41,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "(1, 3, 6)\n"
     ]
    }
   ],
   "source": [
    "numbers = [1,3,6]\n",
    "newNumbers = tuple(map(lambda x:x, numbers))\n",
    "print(newNumbers)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 40.\n",
    "D) syntax error"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 41. if-elif-else\n",
    "a) True"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 43,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "2\n",
      "1\n"
     ]
    }
   ],
   "source": [
    "for i in [1,0]:\n",
    "    print(i+1)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 43. \n",
    "c) Both the loops can have optional else statement"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 57,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "10\n"
     ]
    }
   ],
   "source": [
    "i =sum = 0\n",
    "\n",
    "while i <=4:\n",
    "    sum += i\n",
    "    i= i+1\n",
    "\n",
    "print(sum)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 59,
   "metadata": {},
   "outputs": [
    {
     "ename": "SyntaxError",
     "evalue": "invalid syntax (<ipython-input-59-bc66e8cd9722>, line 1)",
     "output_type": "error",
     "traceback": [
      "\u001b[1;36m  File \u001b[1;32m\"<ipython-input-59-bc66e8cd9722>\"\u001b[1;36m, line \u001b[1;32m1\u001b[0m\n\u001b[1;33m    while 4 =4:\u001b[0m\n\u001b[1;37m            ^\u001b[0m\n\u001b[1;31mSyntaxError\u001b[0m\u001b[1;31m:\u001b[0m invalid syntax\n"
     ]
    }
   ],
   "source": [
    "while 4 =4:\n",
    "    print('4')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 46.\n",
    "b) Yes, for loops is more pythonic choice"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 47. break and continue\n",
    "d) ALL of the above"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 78,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "PYTHONSTRING"
     ]
    }
   ],
   "source": [
    "for char in 'PYTHONSTRING':\n",
    "    if char =='':\n",
    "        break\n",
    "    print(char, end=\"\")\n",
    "    if char =='O':\n",
    "        continue\n",
    "        print(char)\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 49. Pass Function\n",
    "d) All of the above"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 50. CSV and TSV\n",
    "c) Any character such as comma or tab that is used to seperate column data"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 51. CSV and TSV - first row contains\n",
    "a) The column names of the data"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 52. Csv file open\n",
    "c)csv.reader(my_data, delimiter='\\t')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 53.Csv reader iteration\n",
    "b) The row data as a list"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 54.CSV - .Writerow()\n",
    "c)Each key must match up to the field names( column names) used to identify the column data"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 55. CSV file hrdata.csv\n",
    "c) pandas.read_csv('hrdata.csv')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 56. Pandas 0- based\n",
    "a) pandas.read_csv('hrdata.csv', index_col='Name')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 57.reading csv file\n",
    "b) open(\"example.txt\", r)\n",
    "c) open(\"example.txt\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 58. \n",
    "animals/feline"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 59.  \n",
    "open('jack_russell.png', 'rb')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 60.\n",
    "animals/ursine/bears.gif"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 61. \n",
    "d) By using the with statement"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 62.\n",
    "/ursine/bears.gif"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 63.\n",
    "b) .read()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 64.\n",
    "b) 1.7"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 65.\n",
    "b) -2.97"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 66.\n",
    "b) Positive numbers are rounded down and negative numbers are rounded up."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 67.\n",
    "a) -0.05"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 68.\n",
    "d) Round half to even"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 69.\n",
    "a) 4.6"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 70.\n",
    "a) Diamond "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 71.\n",
    "c) Atleast 3"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {},
   "outputs": [],
   "source": [
    "class A:\n",
    "    def test():\n",
    "        print(\"Calling from A\")\n",
    "class B:\n",
    "    def test():\n",
    "        print(\"calling from B\")\n",
    "    \n",
    "class C(A,B):\n",
    "    def test(self):\n",
    "        A.test()\n",
    "        B.test()\n",
    "    \n",
    "\n",
    "    \n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 72.\n",
    "a) class a"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 73.\n",
    "C) Derived class can still access them in multiple inheritance"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 74.\n",
    "d) No, since no constructors wont be there"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 75.\n",
    "a) classes being derived from other derived classes"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 76.\n",
    "a) A"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 77.\n",
    "a) class at first level"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 78.\n",
    "d) as many levels of inheritance used"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 79. \n",
    "b) object of lower classes must call parent"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 80.\n",
    "d) Exception"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 81.\n",
    "c) Runtime exceptions only"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 82.\n",
    "a) Try and catch"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 83.\n",
    "a) An object must be created"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 84.\n",
    "c) IOExceptions"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 85.\n",
    "d) both "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 86.\n",
    "a) catch block of a derived class must be defined before the base class"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 87.\n",
    "b) before derived class not allowed by compiler"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 88.\n",
    "d) classNotFondException"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 89.\n",
    "c) Both "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 90.\n",
    "c) Infinite"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#  91 .\n",
    "c Functions made to maintain a single copy of member functions for all objects\n",
    "        "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 92.\n",
    "C) Only static members of a class"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 93.\n",
    "d) className :: functionName;"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 94.\n",
    "d) created and intialised only once"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 95. \n",
    "b) cant be overloaded"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 96.\n",
    "\n",
    "d) cant be volatile, constant voaltile"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 97.\n",
    "c) single colon"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 98.\n",
    "Those can be initialized within the class"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 99.\n",
    "b) Can’t be mutable"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 100.\n",
    "a) Even if class object is not created"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 101.\n",
    "a) a) Even if class object is not created\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 102.\n",
    "a) reshape, resize"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 103.\n",
    "a) arange"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 104.\n",
    "d) All of the mentioned"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 105.\n",
    "Answer: b"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 106.\n",
    "a) True"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 107.\n",
    "a) view\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 108.\n",
    "b) ix_"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 109.\n",
    "a) True"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 110.\n",
    "d) all of the mentioned"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 111.\n",
    "c) setbufsize(size)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 112.\n",
    "b) In Numpy, universal functions are instances of the numpy.ufunction class"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 113.\n",
    "a) .types"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 114.\n",
    "b) ones_like\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 115.\n",
    "c) The output of the ufunc is necessarily an ndarray, if all input arguments are ndarrays"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 116.\n",
    "b) settercall"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 117.\n",
    "b) False"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 118.\n",
    "c) frexp"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 119.\n",
    "a) iscomplex"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 120.\n",
    "a) True"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 121.\n",
    "c) value, size"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 122.\n",
    "d) All of the mentioned"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 123.\n",
    "a) import pandas as pd"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 124.\n",
    "a) DataFrame"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 125.\n",
    "c) Panel is generally 2D labeled, also size-mutable array"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 126.\n",
    "a) NumPy\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 127.\n",
    "b) False"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 128.\n",
    "c) Statsmodels"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 129.\n",
    "a) yhat"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 130.\n",
    "a) True"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 131.\n",
    "a) Quandl"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 132.\n",
    "a) Statsmodels provides powerful statistics, econometrics, analysis and modeling functionality that is out of panda’s scope"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 133.\n",
    "a) pandaSDMX\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 134.\n",
    "a) Blaze"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 135.\n",
    "c) Spyder is a cross-platform Qt-based open-source R IDE"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 136.\n",
    "b) freedapi"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 137.\n",
    "b) False"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 138.\n",
    "a) scikit-learn"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 139.\n",
    "b) Seaborn"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 140.\n",
    "a) True"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 141.\n",
    "b) SparseArray"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 142.\n",
    "d) All of the mentioned"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 143.\n",
    "d) None of the mentioned"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 144.\n",
    "a) SparseList"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 145.\n",
    "a) to_array. append can accept scalar values or any 2-D sequence"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 146.\n",
    "a) SparseSeries.to_coo()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 147.\n",
    "b) False"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 148.\n",
    "a) in"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 149.\n",
    "b) ix"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 150.\n",
    "a) True"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.3"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
